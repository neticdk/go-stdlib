<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# xslices

```go
import "github.com/neticdk/stdlib/xslices"
```

## Index

- [Constants](<#constants>)
- [func Filter\[T any\]\(data \[\]T, f func\(T\) bool\) \[\]T](<#Filter>)
- [func FindFunc\[T any\]\(data \[\]T, f func\(T\) bool\) \(T, bool\)](<#FindFunc>)
- [func FindIFunc\[T any\]\(data \[\]T, f func\(T\) bool\) \(int, bool\)](<#FindIFunc>)
- [func Fold\[T, S any\]\(acc T, data \[\]S, f func\(T, S\) T\) T](<#Fold>)
- [func FoldR\[T, S any\]\(acc T, data \[\]S, f func\(T, S\) T\) T](<#FoldR>)
- [func Intersect\[T comparable\]\(a, b \[\]T\) \[\]T](<#Intersect>)
- [func Map\[T, U any\]\(data \[\]T, f func\(T\) U\) \[\]U](<#Map>)
- [func Unfold\[T any\]\(acc T, f func\(T\) T, p func\(T\) bool, opts ...UnfoldOption\) \[\]T](<#Unfold>)
- [func UnfoldI\[T any\]\(acc T, f func\(T\) T, n int, opts ...UnfoldOption\) \[\]T](<#UnfoldI>)
- [type UnfoldConfig](<#UnfoldConfig>)
- [type UnfoldOption](<#UnfoldOption>)
  - [func WithMax\(n int\) UnfoldOption](<#WithMax>)
  - [func WithStep\(step int\) UnfoldOption](<#WithStep>)


## Constants

<a name="DefaultMaxIterations"></a>

```go
const (
    DefaultMaxIterations = 100000
    DefaultStep          = 1
)
```

<a name="Filter"></a>
## func [Filter](<https://github.com/neticdk/go-stdlib/blob/main/xslices/filter.go#L5>)

```go
func Filter[T any](data []T, f func(T) bool) []T
```

Filter returns a new slice containing only the elements of the slice that satisfy the predicate.

<a name="FindFunc"></a>
## func [FindFunc](<https://github.com/neticdk/go-stdlib/blob/main/xslices/find.go#L8>)

```go
func FindFunc[T any](data []T, f func(T) bool) (T, bool)
```

FindFunc returns the first element in the slice that satisfies the predicate.

It returns the default value for the type and false if no element satisfies the predicate.

<a name="FindIFunc"></a>
## func [FindIFunc](<https://github.com/neticdk/go-stdlib/blob/main/xslices/find.go#L23>)

```go
func FindIFunc[T any](data []T, f func(T) bool) (int, bool)
```

FindIFunc returns the index of the first element in the slice that satisfies the predicate.

It returns \-1 and false if no element satisfies the predicate

<a name="Fold"></a>
## func [Fold](<https://github.com/neticdk/go-stdlib/blob/main/xslices/fold.go#L6>)

```go
func Fold[T, S any](acc T, data []S, f func(T, S) T) T
```

Fold applies a function to each element of the slice. storing the result in an accumulator. It applies the function from left to right.

<a name="FoldR"></a>
## func [FoldR](<https://github.com/neticdk/go-stdlib/blob/main/xslices/fold.go#L18>)

```go
func FoldR[T, S any](acc T, data []S, f func(T, S) T) T
```

FoldR applies a function to each element of the slice. storing the result in an accumulator. It applies the function from right to left.

<a name="Intersect"></a>
## func [Intersect](<https://github.com/neticdk/go-stdlib/blob/main/xslices/intersect.go#L4>)

```go
func Intersect[T comparable](a, b []T) []T
```

Intersect returns the intersection of two comparable slices.

<a name="Map"></a>
## func [Map](<https://github.com/neticdk/go-stdlib/blob/main/xslices/map.go#L5>)

```go
func Map[T, U any](data []T, f func(T) U) []U
```

Map applies a function to each element of a slice and returns a new slice with the results.

<a name="Unfold"></a>
## func [Unfold](<https://github.com/neticdk/go-stdlib/blob/main/xslices/unfold.go#L37>)

```go
func Unfold[T any](acc T, f func(T) T, p func(T) bool, opts ...UnfoldOption) []T
```

Unfold generates a slice by repeatedly applying a function to an accumulator. It includes the accumulator in the result as the first value. If the predicate is always false, it returns nil. It stops when the predicate returns false.

<a name="UnfoldI"></a>
## func [UnfoldI](<https://github.com/neticdk/go-stdlib/blob/main/xslices/unfold.go#L66>)

```go
func UnfoldI[T any](acc T, f func(T) T, n int, opts ...UnfoldOption) []T
```

UnfoldI generates a slice by repeatedly applying a function to an accumulator. It includes the accumulator in the result as the first value. The length of the result is equal to i \+ 1. If i is negative, it returns nil. It stops after i iterations.

<a name="UnfoldConfig"></a>
## type [UnfoldConfig](<https://github.com/neticdk/go-stdlib/blob/main/xslices/unfold.go#L8-L11>)



```go
type UnfoldConfig struct {
    Max  int
    Step int
}
```

<a name="UnfoldOption"></a>
## type [UnfoldOption](<https://github.com/neticdk/go-stdlib/blob/main/xslices/unfold.go#L13>)



```go
type UnfoldOption func(*UnfoldConfig)
```

<a name="WithMax"></a>
### func [WithMax](<https://github.com/neticdk/go-stdlib/blob/main/xslices/unfold.go#L18>)

```go
func WithMax(n int) UnfoldOption
```

WithStep sets the step of the unfold. This does not include the first step. If n is 5, the length of the result is \<= 6.

<a name="WithStep"></a>
### func [WithStep](<https://github.com/neticdk/go-stdlib/blob/main/xslices/unfold.go#L27>)

```go
func WithStep(step int) UnfoldOption
```

WithStep sets the step of the unfold. This does not include the first step. If step is 2, the result will include every second value.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
